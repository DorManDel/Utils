//

/* ============================================================
 * Complexity Quick Reference
 * ------------------------------------------------------------
 * O(1)      - Constant
 * O(log n)  - Logarithmic
 * O(n)      - Linear
 * O(n log n)- Efficient sorting
 * O(nÂ²)     - Quadratic (small n only)
 * ============================================================ */

/*
 DATA STRUCTURES
 ------------------------------------------------------------
 Structure   | Search | Insert | Delete | Memory | Notes
 ------------------------------------------------------------
 Array       | O(n)   | O(n)   | O(n)   | Low    | Cache-friendly
 BST         | O(n)   | O(n)   | O(n)   | Medium | Can degenerate
 AVL Tree    | O(logn)| O(logn)| O(logn)| Higher | Strictly balanced
 Heap        | O(n)   | O(logn)| O(logn)| Medium | Priority queue
 Hash Table  | O(1)*  | O(1)*  | O(1)*  | High   | Needs hash
 ------------------------------------------------------------
 */

// ----------------------------------------------------------------

// ================================================================
// ----------------------------------------------------------------

ğŸ” Searching Algorithms

// ----------------------------------------------------------------
// ================================================================

Linear Search â€” Î˜(n)

LINEAR-SEARCH(A, n, x)
    for i â† 1 to n
        if A[i] = x
            return i
    return NIL


// ----------------------------------------------------------------

Binary Search â€” Î˜(log n)

BINARY-SEARCH(A, low, high, x)
    if low > high
        return NIL
    mid â† âŒŠ(low + high) / 2âŒ‹
    if A[mid] = x
        return mid
    else if A[mid] > x
        return BINARY-SEARCH(A, low, mid âˆ’ 1, x)
    else
        return BINARY-SEARCH(A, mid + 1, high, x)

// ================================================================
// ----------------------------------------------------------------

ğŸ”ƒ Sorting Algorithms::

// ----------------------------------------------------------------
// ================================================================

Insertion Sort â€” Î˜(nÂ²), stable, in-place

INSERTION-SORT(A)
    for j â† 2 to length[A]
        key â† A[j]
        i â† j âˆ’ 1
        while i > 0 âˆ§ A[i] > key
            A[i + 1] â† A[i]
            i â† i âˆ’ 1
        A[i + 1] â† key

// ----------------------------------------------------------------

Merge Sort â€” Î˜(n log n)

MERGE-SORT(A, p, r)
    if p < r
        q â† âŒŠ(p + r) / 2âŒ‹
        MERGE-SORT(A, p, q)
        MERGE-SORT(A, q + 1, r)
        MERGE(A, p, q, r)

// ----------------------------------------------------------------

Quick Sort â€” Î˜(n log n) avg, Î˜(nÂ²) worst

QUICKSORT(A, p, r)
    if p < r
        q â† PARTITION(A, p, r)
        QUICKSORT(A, p, q âˆ’ 1)
        QUICKSORT(A, q + 1, r)

// ================================================================
// ----------------------------------------------------------------

ğŸŒ² Trees::

// ----------------------------------------------------------------
// ================================================================

Tree Node Structure:

node.key
node.left
node.right
node.parent // aka root

// ----------------------------------------------------------------

Binary Search Tree Search â€” Î˜(h)

TREE-SEARCH(x, k)
    if x = NIL or k = x.key
        return x
    if k < x.key
        return TREE-SEARCH(x.left, k)
    else
        return TREE-SEARCH(x.right, k)

// ----------------------------------------------------------------

Inorder Traversal (BST sorted output)

INORDER-TREE-WALK(x)
    if x â‰  NIL
        INORDER-TREE-WALK(x.left)
        PRINT x.key
        INORDER-TREE-WALK(x.right)

// ================================================================
// ----------------------------------------------------------------

ğŸ“š Stack (LIFO)::

// ----------------------------------------------------------------
// ================================================================

PUSH(S, x)
    top[S] â† top[S] + 1
    S[top[S]] â† x


POP(S)
    if top[S] = 0
        error
    top[S] â† top[S] âˆ’ 1
    return S[top[S] + 1]

// ================================================================
// ----------------------------------------------------------------

ğŸ“¥ Queue (FIFO)::

// ----------------------------------------------------------------
// ================================================================

ENQUEUE(Q, x)
    Q[tail] â† x
    tail â† tail + 1

DEQUEUE(Q)
    x â† Q[head]
    head â† head + 1
    return x

// ================================================================
// ----------------------------------------------------------------

ğŸŒ Graph Algorithms::

// ----------------------------------------------------------------
// ================================================================

Breadth-First Search (BFS) â€” Î˜(V + E)

BFS(G, s)
    for each vertex v âˆˆ G.V
        v.color â† WHITE
        v.d â† âˆ
        v.parent â† NIL
    s.color â† GRAY
    s.d â† 0
    ENQUEUE(Q, s)

    while Q not empty
        u â† DEQUEUE(Q)
        for each v âˆˆ G.Adj[u]
            if v.color = WHITE
                v.color â† GRAY
                v.d â† u.d + 1
                v.parent â† u
                ENQUEUE(Q, v)
        u.color â† BLACK

// ================================================================
// ----------------------------------------------------------------

Depth-First Search (DFS) â€” Î˜(V + E)

DFS(G)
    for each vertex u âˆˆ G.V
        u.color â† WHITE
        u.parent â† NIL
    time â† 0
    for each vertex u âˆˆ G.V
        if u.color = WHITE
            DFS-VISIT(G, u)

// ----------------------------------------------------------------
// ================================================================

â± Complexity Reference::

Algorithm	Time
Linear Search	Î˜(n)
Binary Search	Î˜(log n)
Insertion Sort	Î˜(nÂ²)
Merge Sort	Î˜(n log n)
Quick Sort	Î˜(n log n) avg
BST ops	Î˜(h)
BFS / DFS	Î˜(V + E)

// ----------------------------------------------------------------
// ================================================================